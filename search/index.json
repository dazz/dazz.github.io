{"pages":[{"date":"2023-01-02","image":"https://dazz.github.io/posts/2023-01-02_environment-variables-in-a-dockerized-symfony//amy-humphries-2M_sDJ_agvs-unsplash.jpg","imageAlt":"","link":"https://dazz.github.io/posts/2023-01-02_environment-variables-in-a-dockerized-symfony/","summary":"I have developed a Symfony Web-Application and I run it locally in a dockerized environment with docker-compose. Now this app is going to be deployed to production as a docker container.","tags":["cd","ci","docker","docker-compose","dotenv","env_file","symfony"],"text":"i have developed a symfony web-application and i run it locally in a dockerized environment with docker-compose. now this app is going to be deployed to production as a docker container. but in production the handling of environment variables and how they are passed to the container during development is different. i was searching for options and i found there are at least\n7 ways to pass environment variables to a container env in dockerfile dockerfile args passed at build time to env env passing in docker run as option env_file in docker run as option environment variables in docker-compose.yml env_file in docker compose for each service .env in docker compose substitutes variables in docker-compose.yml this is my journey figuring out which option matches my requirements.\nthis is a good summary if you\u0026rsquo;re interested: environment variables in container vs. docker compose file\nthe big picture we use multiple services which all need to work together we deploy and run services in different compositions for each environment each service has their own sensitive data each service might be a different technology or has a different tech stack the requirements all services regardless of which technology they use, should have one streamlined way of how the environment variables should be passed.\nthis is what i recommend the infrastructure config should be kept in env files but not in the same directory as the application each service gets its own env file to be completely independent of each other, and it gets explicitly set during development each service gets the env variables passed via env file every project that has a docker-compose.yml moves the application into an app directory to separate the application from its infrastructure configuration we remove the dotenv component from symfony and define each environment variable that we expect as parameter so the app tells us instantly when a key-value pair is missing in development credentials can be added to the vcs in all other envs the credentials can be either stored and linked on the server or be read from a vault the implementation in symfony the dotenv component is default enabled in the frontcontroller, so when a new app is created there is always a .env file at the project root created with it. read more in the documentation.\nit is not the same .env that docker-compose.yml expects.\ndocker compose is also using a .env file to replace the variables in the docker-compose.yml if it is located in the same directory. if you don\u0026rsquo;t know that and put the web apps .env file in the same place then you accidentaly might overwrite variables when you think you just updated a variable for the symfony application.\nwe have two different trades here that both want to use the .env file and both might, but not at the same time, obviously.\nthe directory tree . ├── app │ ├── assets │ ├── bin │ ├── ci │ ├── config │ ├── migrations │ ├── node_modules │ ├── public │ │ └── index.php │ ├── src │ ├── templates │ ├── tests │ ├── var │ ├── vendor │ ├── composer.json │ ├── composer.lock │ ├── makefile │ ├── package.json │ ├── symfony.lock │ ├── webpack.config.js │ └── yarn.lock ├── devops │ ├── database │ ├── docker │ │ └── frankenphp │ │ └── dockerfile │ └── env │ ├── dev.app.env │ └── dev.database.env ├── contributing.md ├── docker-compose.prod.yml ├── docker-compose.yml ├── makefile └── readme.md the application code moved into the ./app directory to be completely separate from the code/config that defines the infrastructure. you see there is no .env file left from symfony.\nthe docker-compose.yml version: \u0026#39;3.9\u0026#39; services: app: image: ghcr.io/c-base/cbag3:dev-latest build: dockerfile: ./devops/docker/frankenphp/dockerfile target: dev env_file: ./devops/env/dev.app.env ports: - 80:80 - 443:443 volumes: - \u0026#39;./app:/app\u0026#39; database: image: postgres:alpine container_name: database env_file: ./devops/env/dev.database.env ports: - 15432:5432 volumes: - ./devops/database:/var/lib/postgresql each service gets its own env_file , the .env coud be used to configure variables insider the docker-compose.yml but until we need it, it will be left out.\ndisable dotenv in frontcontroller and console # app/public/index.php \u0026lt;?php use cbase\\app\\kernel; $_server[\u0026#39;app_runtime_options\u0026#39;][\u0026#39;disable_dotenv\u0026#39;] = true; require_once dirname(__dir__).\u0026#39;/vendor/autoload_runtime.php\u0026#39;; return function (array $context) { return new kernel($context[\u0026#39;app_env\u0026#39;], (bool) $context[\u0026#39;app_debug\u0026#39;]); }; # app/bin/console #!/usr/bin/env php \u0026lt;?php use cbase\\app\\kernel; use symfony\\bundle\\frameworkbundle\\console\\application; $_server[\u0026#39;app_runtime_options\u0026#39;][\u0026#39;disable_dotenv\u0026#39;] = true; require_once dirname(__dir__) . \u0026#39;/vendor/autoload_runtime.php\u0026#39;; return function (array $context) { $kernel = new kernel($context[\u0026#39;app_env\u0026#39;], (bool) $context[\u0026#39;app_debug\u0026#39;]); return new application($kernel); }; see described here: configure symfony runtime using options\nkeep dotenv for tests for now, we leave the dotenv for the tests since those environment variables won\u0026rsquo;t change regardless of where they are executed and they will be executed in the dev container. we could change that by running the tests in their own container, but for now keep the .env.test.\ndon\u0026rsquo;t forget to add the parameters in services.yml # app/config/services.yaml parameters: images.upload.directory: \u0026#39;%env(resolve:images_upload_directory)%\u0026#39; services: _defaults: autowire: true autoconfigure: true bind: string $imagesuploaddirectory: \u0026#39;%images.upload.directory%\u0026#39; since every environment has its own env_file there is the danger of forgetting to add an environment variable to the other environments. in order to fail early we load the environment variable at the start of the application and not at the point in time when the service is required as that leads to undiscovered failures.\nconclusion we removed the dotenv from symfony and will miss out on all the functionality that came with it, but chose using the env_file as it can be used for running a container and it can be configured in the docker-compose.yml. the environment configs can be dumped from secret vaults regardless of the tech-stack that the cloud has to offer or kept in a shared directory that won\u0026rsquo;t change between deployments. there will be one explicit way of how each service will get configuration regardless of their environment or tech stack.\nhappy continuously deploying everyone ","title":"Environment variables in a dockerized Symfony"},{"date":"2022-12-28","image":"https://dazz.github.io/posts/2022-12-28_build-and-push-docker-images-to-ghcr-with-github-actions//dockergithub.png","imageAlt":"","link":"https://dazz.github.io/posts/2022-12-28_build-and-push-docker-images-to-ghcr-with-github-actions/","summary":"When you host your project code on GitHub and want to release it as a docker image for deployment or just publish it, the way to go are GitHub actions. It’s basically hooks that can start CI/DC workflows on repository events.","tags":["cd","docker","github","github-actions","github-packages"],"text":"when you host your project code on github and want to release it as a docker image for deployment or just publish it, the way to go are github actions. it’s basically hooks that can start ci/dc workflows on repository events.\ngithub actions can be used to build and push images to githubs container registry which are reachable under https://ghcr.io which is part of the package registry. the package registry is not only for docker images, it can also host quite a few other kinds of packages. in this case we’ll focus on docker images.\nprerequisites: github repository basic knowledge about github actions syntax dockerfile the github workflow i created a workflow in my repository under .github/workflow/cd.md and added the following:\nname: continuous delivery on: push: branches: - \u0026#39;main\u0026#39; tags: - \u0026#39;v*.*.*\u0026#39; jobs: build: name: buid and push docker image to github container registry runs-on: ubuntu-latest permissions: packages: write contents: read steps: - name: checkout the repository uses: actions/checkout@v3 - name: docker setup buildx uses: docker/setup-buildx-action@v2.2.1 - name: docker login uses: docker/login-action@v2.1.0 with: registry: ghcr.io username: ${{ github.actor }} password: ${{ secrets.github_token }} - name: build and push docker images uses: docker/build-push-action@v3.2.0 env: registry: ghcr.io image_name: ${{ github.repository }} with: context: . file: ./dockerfile target: final push: true tags: ${{ env.registry }}/${{ env.image_name }}:latest let’s go through the important parts: permissions: actions have access to the repo while running. we should always make sure by setting the permissions, that actions have the minimum access they require. see here: permissions for the github_token\nstep 1-2: checkout the code and setup docker**\nstep 3: login to github container registry: this is where the interesting part starts. the github.actor that will be the user that triggered the workflow. for password use secrets.github_token which is a temporary token which is automatically generated for this workflow. see here: publishing images to github-packages\nstep 4: build and push docker images: if the registry that you want to push to belongs to an organization then you will need to add permission to create packages. if it lives under your own handle you don\u0026rsquo;t need to configure anything more since you are then the owner already and the secrets.github_token has all the permissions granted by that.\nstraight forward the action will consume the dockerfile build to the target build step that you can define. in docker there is this thing that the repository whre the image will be hosted is also part of the tag. setting the image to the repository name will create an image with the following tag: `ghcr.io/owner/image_name:latest read more here: pushing container images\nhappy shipping \\o/ ","title":"Build and push docker images to ghcr.io with GitHub Actions"},{"date":"2022-12-27","image":"https://dazz.github.io/posts/2022-12-27_goodbye-jekyl-hello-hugo//hugo.png","imageAlt":"","link":"https://dazz.github.io/posts/2022-12-27_goodbye-jekyl-hello-hugo/","summary":"I started this blog in March 2013 when I was working for ImagineEasy when I had a few ideas to write down on how I\u0026rsquo;d work with Doctrine Repositories. I still like the idea, but I\u0026rsquo;d probably do it a bit different today.","tags":["blog","cd","git","github","github-actions","hugo","jekyll"],"text":"i started this blog in march 2013 when i was working for imagineeasy when i had a few ideas to write down on how i\u0026rsquo;d work with doctrine repositories. i still like the idea, but i\u0026rsquo;d probably do it a bit different today. the blog and also how i\u0026rsquo;d work with doctrine.\nat the time jekyll was the way to handle a static file blog. since then, again, a few things have changed. github is now owned by microsoft and there are github actions.\njekyll still exists, but all in all i think it was a modern choice at a different time. so what\u0026rsquo;s next then? i must admit i did not look far, it was more a zeitgeist thing that just ran my way.\nsomeone mentioned hugo as a blog that you can easily publish to from obsidian, i\u0026rsquo;m not planning on using that particular feature, but i looked hugo up, and it seems that it is exactly what i was to lazy to look for. a static site generator that uses markdown and can be build by github actions.\nthere is already a huge list of possible themes and many look promising from the thumbnail, but feature wise there is a huge difference. what to look out for:\nhow far is the template deviating from the default, in case you ever want to change the template. which features do you want/need and are they already included, is it complicated to add them later? are there existing installations that are actively used, so they can be used as a reference is there a reference/documentation on how to install it on the host how do you publish new content, are there examples/documentation? what is the version of the technologies in the deploy-chain, old? for every point there is also the question of how complicated each step is.\nas a reference, this is what i ended up doing:\nlocal setup install hugo sudo apt-get install hugo create a new site see the official quick start for more infos.\nhugo new site dazz.github.io cd dazz.github.io git init add a theme look at all the blog themes hugo already has listed.\ni chose hugo-ficurinia as it has the following enabled: tags, categories, fonts i like, simply deploys and looks as promised.\nadd the theme as submodule:\ngit submodule add https://gitlab.com/gabmus/hugo-ficurinia themes/hugo-ficurinia and run a local server to test everything\nhugo server -t hugo-ficurinia add a blog post there is probably nothing much to see, so let\u0026rsquo;s add a new post as draft.\nhugo new posts/hello-world/index.md make sure to read about how to organize the content in directories.\nrun the server and run the server again and also include the draft post\nhugo server -t hugo-ficurinia --builddrafts when you run just hugo -t hugo-ficurinia the site will be build and dumped to public/. that is what we will later do to deploy the site.\ntime to commit all the changed files and add the remote to push everything\ngit remote add origin git@github.com:dazz/dazz.github.io.git git push origin main there will nothing happen yet as we still need to add the github workflow\ndeploy to github pages via github actions mkdir -p .github/workflows touch .github/workflows/pages-deploy.yml # file: .github/workflows/pages-deploy.yml name: \u0026#34;build and deploy gh-pages\u0026#34; on: push: branches: - main paths-ignore: - .gitignore - readme.md - license # allows you to run this workflow manually from the actions tab workflow_dispatch: permissions: contents: write # needed to push to the gh-pages branch pages: write id-token: write # allow one concurrent deployment concurrency: group: \u0026#34;pages\u0026#34; cancel-in-progress: true jobs: build: runs-on: ubuntu-latest steps: # step 1 - checks-out your repository under $github_workspace - name: checkout uses: actions/checkout@v3 with: fetch-depth: 0 submodules: true # step 2 - sets up the latest version of hugo - name: hugo setup uses: peaceiris/actions-hugo@v2.6.0 with: extended: true hugo-version: \u0026#39;latest\u0026#39; # step 3 - adds a cache - uses: actions/cache@v2 with: path: /tmp/hugo_cache key: ${{ runner.os }}-hugomod-${{ hashfiles(\u0026#39;**/go.sum\u0026#39;) }} restore-keys: | ${{ runner.os }}-hugomod- # step 4 - clean and don\u0026#39;t fail - name: clean public directory run: rm -rf public/* # step 5 - builds the site using the latest version of hugo # also specifies the theme we want to use - name: build run: hugo --minify --theme=hugo-ficurinia # step 6 - push our generated site to our gh-pages branch - name: github pages action uses: peaceiris/actions-gh-pages@v3.9.0 with: github_token: ${{ secrets.github_token }} publish_dir: ./public cname: dazz.github.io read more about the options you get when using peaceiris/actions-hugo and peaceiris/actions-gh-pages.\ncustomization now the customization party can start. all the options are listed in the config.toml.\nhappy blogging \\o/ ","title":"Goodbye Jekyll, hello Hugo"},{"date":"2022-12-26","image":"","imageAlt":"","link":"https://dazz.github.io/posts/2022-12-26_hello-world/","summary":"Introduction This is bold text, and this is emphasized text.\nVisit the Hugo website!","tags":["first"],"text":"introduction this is bold text, and this is emphasized text.\nvisit the hugo website!\n","title":"Hello, world!"},{"date":"0001-01-01","image":"","imageAlt":"","link":"https://dazz.github.io/about/","summary":"References Logo: Bild von catalyststuff auf Freepik ","tags":[],"text":"references logo: bild von catalyststuff auf freepik ","title":""}]}